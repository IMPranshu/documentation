---
# Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "Reads and writes"
---

<p>
  This guide covers the aspects of accessing <a href="documents.html">documents</a> in Vespa.
  Documents are stored in <em>content</em> clusters.
  Writes (PUT, UPDATE, DELETE) and reads (GET) pass through a <em>container</em> cluster.
  Find a more detailed flow at the end of this article.
</p>
<img src="img/overview/vespa-overview.svg" style="padding:10px">
<p>
Vespa's indexing structures are built for high-rate, memory-only operations for field updates.
Refer to the <a href="performance/sizing-feeding.html">feed sizing guide</a> for write performance.
<!-- ToDo: once partial-update.html is done, link there -->
</p><p>
Vespa supports <a href="parent-child.html">parent/child</a> for de-normalized data.
This can be used to simplify the code to update application data,
as one write will update all children documents.
</p><p>
  Applications can add custom feed <a href="document-processing.html">document processors</a>
  and multiple container clusters - see <a href="indexing.html">indexing</a> for details.
</p>
<table class="table">
<tbody>
<tr>
  <th>Get</th>
  <td><p>
    Get a document by ID.
  </p></td>
</tr><tr>
  <th>Put</th>
  <td><p>
    Write a document by ID - a document is overwritten if a document with the same document ID exists.
  </p></td>
</tr><tr>
  <th>Remove</th>
  <td><p>
    Remove a document by ID.
    If the document to be removed is not found, it is not considered a failure -
    the call returns a reply stating that no document was found.
    Read more about <a href="operations/admin-procedures.html#data-retention-vs-size">data-retention</a>.
  </p></td>
</tr><tr>
  <th>Update</th>
  <td><p>
    Also referred to as <em>partial update</em>, as it updates some/all fields of a document by ID.
    If the document to update does not exist, the update returns a reply
    stating that no document was found.
    </p><p>
    Update supports <a href="#create-if-nonexistent">create if nonexistent</a>.
    </p><p>
    All data structures (<a href="attributes.html">attribute</a>,
    <a href="proton.html#index">index</a> and <a href="document-summaries.html">summary</a>) are updatable.
    Note that only <em>assign</em> and <em>remove</em> are idempotent -
    message re-sending can apply updates more than once.
    Use <em>conditional writes</em> for stronger consistency.
    </p>
    <table class="table">
      <tr>
        <td><strong>All field types</strong></td>
        <td><ul>
            <li><code><a href="reference/document-json-format.html#assign">assign</a></code> (may also be used to clear fields)</li>
        </ul></td>
      </tr><tr>
        <td><strong>Numeric field types</strong></td>
        <td><ul>
            <li><code><a href="reference/document-json-format.html#arithmetic">increment</a></code>
              See <a href="#create-if-nonexistent-keys">create if nonexistent - keys</a>
              for how to auto-create keys in weighted sets</li>
            <li><code><a href="reference/document-json-format.html#arithmetic">decrement</a></code></li>
            <li><code><a href="reference/document-json-format.html#arithmetic">multiply</a></code></li>
            <li><code><a href="reference/document-json-format.html#arithmetic">divide</a></code></li>
        </ul></td>
      </tr><tr>
        <td><strong>Composite types</strong></td>
        <td><ul>
            <li><code><a href="reference/document-json-format.html#add">add</a></code>
              For <em>array</em> and <em>weighted set</em>.
              To put into a <em>map</em>,
              see the <a href="reference/document-json-format.html#assign">assign</a> section</li>
            <li><code><a href="reference/document-json-format.html#remove">remove</a></code></li>
            <li><code><a href="reference/document-json-format.html#match">match</a></code>
              Pick element from collection, then apply given operation to matched element</li>
            <li><a href="reference/document-json-format.html#fieldpath">
              accessing elements within a composite field using fieldpaths</a></li>
        </ul></td>
      </tr><tr>
        <td><strong>Tensor types</strong></td>
        <td><ul>
            <li><code><a href="reference/document-json-format.html#tensor-modify">modify</a></code>
              Modify individual cells in a tensor - can replace, add or multiply cell values</li>
            <li><code><a href="reference/document-json-format.html#tensor-add">add</a></code>
              Add cells to mapped or mixed tensors</li>
            <li><code><a href="reference/document-json-format.html#tensor-remove">remove</a></code>
              Remove cells from mapped or mixed tensors</li>
        </ul></td>
      </tr>
    </table>
  </td>
</tr>
</tbody>
</table>



<h2 id="conditional-writes">Conditional writes</h2>
<p>
A <em>test and set</em> <em>condition</em> can be added to Put, Remove and Update operations.
The <em>condition</em> is a <a href="reference/document-select-language.html">document selection</a>.
Refer to the <a href="reference/document-json-format.html#test-and-set">test-and-set reference</a>.
</p><p>
Example: Increment the <em>sales</em> field only if it is already equal to 999:
<pre>
{
    "update": "id:music:music::BestOf",
        "condition": "music.sales==999",
        "fields": {
            "sales": {
                "increment": 1
            }
    }
}
</pre>
<strong>Note:</strong> Use <em>documenttype.fieldname</em> (e.g. music.sales) in the condition,
not only <em>fieldname</em>.
</p><p>
<strong>Note:</strong> If the condition is not met, an error is returned.
<strong>ToDo:</strong> There is a discussion whether to change to not return error,
and instead return a <em>condition-not-met</em> in the response.
</p>



<h2 id="create-if-nonexistent">Create if nonexistent</h2>
<p>
Updates to nonexistent documents are supported using
<a href="reference/document-json-format.html#create">create</a>.
An empty document is created on the content nodes, before the update is applied.
This simplifies client code in the case of multiple writers.
Example using the <a href="document-api-guide.html">Java Document API</a>:
<pre>
public DocumentUpdate createUpdate(DocumentType musicType) {
    DocumentUpdate update = new DocumentUpdate(musicType, "id:mynamespace:music::http://music.yahoo.com/bobdylan/BestOf");
    update.setCreateIfNonExistent(true);
    return update;
}
</pre>
<em>create</em> can be used in combination with a
<a href="#conditional-writes">condition</a>.
If the document does not exist, the condition will be ignored
and a new document with the update applied is automatically created.
Otherwise, the condition must match for the update to take place.
</p><p>
<strong>Caution:</strong> if all existing replicas of a document are missing <!-- ToDo: rewrite this / move to elastic-vespa details ... -->
when an update with <em>"create": true</em> is executed,
a new document will always be created.
This happens even if a condition has been given.
If the existing replicas become available later,
their version of the document will be overwritten by the newest update since it has a higher timestamp.
</p>



<h2 id="create-if-nonexistent-keys">Create if nonexistent - keys</h2>
<p>
If a key is missing in a weighted set field,
it can be <a href="reference/schema-reference.html#weightedset">auto created</a>
before incrementing its key value:
<pre>
field tag type weightedset<string> {
    indexing: attribute | summary
    weightedset {
        create-if-nonexistent
        remove-if-zero
    }
}
</pre>
The above also auto-deletes the key if decremented to 0.
</p>



<h2 id="api-and-utilities">API and utilities</h2>
<p>
Documents are created using <a href="reference/document-json-format.html">JSON</a> or in
<a href="https://github.com/vespa-engine/vespa/blob/master/document/src/main/java/com/yahoo/document/Document.java">Java</a>:
<table class="table">
  <tr>
    <td><a href="reference/document-v1-api-reference.html">/document/v1/</a></td>
    <td>API for get, put, remove, update, visit.</td>
  </tr><tr>
    <td><a href="vespa-feed-client.html">vespa-feed-client</a></td>
    <td>
      <ul>
        <li>Java library and command line client for feeding document operations using /document/v1/ over HTTP/2</li>
        <li>Asynchronous, high-performance Java implementation, with retries and dynamic throttling</li>
        <li>Simpler alternative to the Vespa HTTP client (below)</li>
        <li>Supports a JSON array of feed operations, as well as JSONL: one operation JSON per line</li>
      </ul>
    </td>
  </tr><tr>
    <td><a href="vespa-http-client.html">Vespa HTTP client</a></td>
    <td>
      <strong>Note:</strong> This will be replaced by the <em>vespa-feed-client</em>.
      Jar writing to Vespa either by method calls in Java or from the command line.
      It provides a simple API with high performance using multiplexing and multiple parallel async connections.
      It is recommended in all cases when feeding from a node outside the Vespa cluster.</td>
  </tr><tr>
    <td style="white-space: nowrap"><a href="document-api-guide.html">Java Document API</a></td>
    <td>Provides direct read-and write access to Vespa documents using Vespa's internal communication layer.
      Use this when accessing documents from Java components in Vespa
      such as <a href="searcher-development.html">searchers</a> and
      <a href="document-processing.html">document processors</a>.</td>
  </tr><tr>
    <td><a href="reference/vespa-cmdline-tools.html#vespa-feeder">vespa-feeder</a></td>
    <td>Utility to feed data with high performance.
      <a href="reference/vespa-cmdline-tools.html#vespa-get">vespa-get</a> gets single documents,
      <a href="reference/vespa-cmdline-tools.html#vespa-visit">vespa-visit</a> gets multiple.</td>
  </tr>
</table>
</p>



<h2 id="feed-block">Feed block</h2>
<p>
A content cluster blocks external write operations when at least one content node has reached the
<a href="reference/services-content.html#resource-limits">resource limit</a>
of disk or memory. This is done to avoid saturating content nodes.
The <em>Cluster controller</em> monitors the resource usage of the content nodes
and decides whether to block feeding.
When feed is blocked, write operations are rejected by <em>Distributors</em>.
All Put operations and most Update operations are rejected.
These operations are still allowed:
<ul>
  <li>Remove operations</li>
  <li>Update <code><a href="reference/document-json-format.html#assign">assign</a></code> operations to numeric single-value fields</li>
</ul>
</p>
<p>
To remedy, add nodes to the content cluster, or use nodes with higher capacity.
The data will <a href="elastic-vespa.html">auto-redistribute</a>, and feeding is unblocked when all content nodes are below the limits.
Configure <a href="reference/services-content.html#resource-limits">resource-limits</a> to tune this.
</p>
<p>
These <a href="reference/metrics.html">metrics</a> are used to monitor resource usage and whether feeding is blocked:
<table class="table">
  <tr>
    <th>cluster-controller.resource_usage.nodes_above_limit</th>
    <td>The number of content nodes that are above one or more resource limits. When above 0, feeding is blocked.</td>
  </tr>
  <tr>
    <th>content.proton.resource_usage.disk</th>
    <td>A number between 0 and 1, indicating how much disk (of total available) is used on the content node.</td>
  </tr>
  <tr>
    <th>content.proton.resource_usage.memory</th>
    <td>A number between 0 and 1, indicating how much memory (of total available) is used on the content node.</td>
  </tr>
</table>
When feeding is blocked, error messages are returned in write operation replies - example:
<pre>
ReturnCode(NO_SPACE, External feed is blocked due to resource exhaustion:
                     memory on node 0 [my-vespa-node-0.example.com] (0.82 > 0.80))
</pre>
</p>

<p>
The address space used in <em>Attribute Multivalue Mapping</em> or <em>Attribute Enum Store</em> can also go full and block feeding -
see <a href="attributes.html#data-structures">attribute data structures</a>.
This will very rarely happen.
</p>
<table class="table">
  <tr>
    <th style="white-space:nowrap;">Attribute Multivalue Mapping</th>
    <td>
      <table class="table">
        <tr>
          <th>default</th>
          <td><a href="https://github.com/vespa-engine/vespa/blob/master/searchcore/src/vespa/searchcore/config/proton.def">
            writefilter.attribute.multivaluelimit</a></td>
        </tr>
        <tr>
          <th>metric</th>
          <td>Use <em>content.proton.documentdb.attribute.resource_usage.multi_value.average</em> to track usage.</td>
        </tr>
        <tr>
          <th>description</th>
          <td>
            For array or weighted set attribute fields,
            there is a max limit on the number of documents that can have the same number of values.
            The limit is 2 billion documents per node.
          </td>
        </tr>
      </table>
    </td>
  </tr>
  <tr>
    <th style="white-space:nowrap;">Attribute Enum Store</th>
    <td>
      <table class="table">
        <tr>
          <th>default</th>
          <td><a href="https://github.com/vespa-engine/vespa/blob/master/searchcore/src/vespa/searchcore/config/proton.def">
            writefilter.attribute.enumstorelimit</a></td>
        </tr>
        <tr>
          <th>metric</th>
          <td>Use <em>content.proton.documentdb.attribute.resource_usage.enum_store.average</em> to track usage.</td>
        </tr>
        <tr>
          <th>description</th>
          <td>
            For string attribute fields or attribute fields with
            <a href="attributes.html#fast-search">fast-search</a>,
            there is a max limit on the number of unique values that can be stored for that attribute.
            The limit is approx 2 billion documents per node.
          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<p>
An error is returned when an attribute limit is exceeded:
<pre>
ReturnCode(NO_SPACE, External feed is blocked due to resource exhaustion:
                     attribute-enum-store:test.ready.a1 on node 0 [my-vespa-node-0.example.com] (0.91 > 0.90))
</pre>
To fix a problem with too many values,
add content nodes to distribute documents with attributes over more nodes -
i.e. reduce number of documents per node.
</p>



<h2 id="consistency">Consistency</h2>
<p>
Read the reference at <a href="content/consistency.html">Vespa consistency model</a>.
Vespa is <em>eventually consistent</em> -
find details on dynamic behavior in <a href="elastic-vespa.html#consistency">elastic Vespa</a>.
</p><p>
It is recommended to use the same client instance for updating a given document -
both for data consistency but also
<a href="performance/sizing-feeding.html#concurrent-mutations">performance</a> (see <em>concurrent mutations</em>).
Read more on write operation <a href="content/content-nodes.html#ordering">ordering</a>.
For performance, group field updates to the same document into
<a href="performance/sizing-feeding.html#client-roundtrips">one update operation</a>.
</p>



<h2 id="dropped-writes-document-expiry">Dropped writes - document expiry</h2>
<p>
Applications can <a href="documents.html#document-expiry">auto-expire documents</a>.
This feature also blocks PUTs to documents that are already expired -
see <a href="indexing.html#document-selection">indexing</a> and
<a href="reference/services-content.html#documents">document selection</a>.
This is a common problem when feeding test data with timestamps,
and the writes a silently dropped.
</p>



<h2 id="batch-delete">Batch delete</h2>
<p>
Options for batch deleting documents:
</p>
<ol>
  <li>
    Find documents using a query, delete, repeat. Pseudocode:
<pre>
while True; do
   query and read document ids, if empty exit
   delete document ids using <a href="reference/document-v1-api-reference.html#delete">/document/v1</a>
   wait a sec # optional, add wait to reduce load while deleting
</pre>
  </li>
  <li>
    Like 1, but use the <a href="vespa-feed-client.html">Vespa feed client</a>.
    Instead of deleting one-by-one, stream remove operations to the API (write a Java program for this),
    or append to a file and use the binary:
<pre>
$ vespa-feed-client --file deletes.json --endpoint my-endpoint
</pre>
  </li>
  <li>
    Use a <a href="documents.html#document-expiry">document selection</a> to expire documents.
    This deletes all documents <em>not</em> matching the expression.
    It is possible to use parent documents and imported fields for expiry of a document set.
    The content node will iterate over the corpus and delete documents (that are later compacted out):
<pre>
&lt;documents garbage-collection="true"&gt;
    &lt;document type="mytype" selection="mytype.version &amp;gt; 4" &gt;
&lt;/documents&gt;
</pre>
  </li>
  <li>
    Use <a href="reference/document-v1-api-reference.html#delete">/document/v1</a> to delete documents
    identified by a <a href="reference/document-select-language.html">document selection</a> -
    example dropping all documents from the <em>my_doctype</em> schema:
<pre>
$ curl -X DELETE --cert data-plane-public-cert.pem --key data-plane-private-key.pem \
  "$ENDPOINT/document/v1/my_namespace/my_doctype/docid?selection=my_doctype&amp;cluster=my_cluster"
</pre>
  </li>
</ol>



<h2 id="components">Components</h2>
<p>
  Use the <a href="vespa-feed-client.html">vespa-feed-client</a>
  or <a href="reference/document-v1-api-reference.html">/document/v1/ API</a> directly to read and write documents.
  (Note that the <a href="vespa-http-client.html">vespa-http-client</a> will be discontinued,
  use the <em>vespa-feed-client</em> as a drop-in replacement).
  Alternatively, use <a href="reference/vespa-cmdline-tools.html#vespa-feeder">vespa-feeder</a> to feed files
  or the <a href="reference/document-v1-api-reference.html">Java Document API</a>.
</p>
<p>
  Next is <a href="indexing.html">indexing</a>
  and/or <a href="document-processing.html">document processing</a>
  where documents are prepared for indexing (and optionally processed using custom code),
  before being sent to the <em>content node</em>.
  The <em>distributor</em> maps the document to bucket, and sends it to <em>proton</em> nodes:
</p>
<img src="content/img/elastic-feed-container.svg" height="410" width="340"/>
<img src="content/img/elastic-feed-vespafeeder.svg" height="410" width="340"/>
<p></p>
<table class="table">
  <thead></thead><tbody>
<tr id="document-processing">
  <th style="white-space: nowrap">Document processing</th>
  <td>
    The <a href="document-processing.html">document processing chain</a>
    is a chain of processors that manipulate documents before they are stored.
    Document processors can be user defined.
    When using indexed search, the final step in the chain prepares documents for indexing.
    The Document API forwards requests to distributors.
    It calculates the correct content node using
    the distribution algorithm and the <a href="content/content-nodes.html#cluster-state">cluster state</a>.
    With no known cluster state, the client library will send requests to a random node,
    which replies with the updated cluster state if the node was incorrect.
    Cluster states are versioned, such that clients hitting outdated distributors do not override
    updated states with old states.
  </td>
</tr><tr id="distributor">
  <th>Distributor</th>
  <td>
    <p>
      The <a href="content/content-nodes.html#distributor">distributor</a> keeps track of
      which content nodes that stores replicas of each bucket (maximum one replica each),
      based on <a href="reference/services-content.html#redundancy">redundancy</a>
      and information from the <em>cluster controller</em>.
      A bucket maps to one distributor only.
      A distributor keeps a bucket database with bucket metadata.
      The metadata holds which content nodes store replicas of the buckets,
      the checksum of the bucket content and the number of documents and meta entries within the bucket.
      Each document is algorithmically mapped to a bucket and forwarded to the correct content nodes.
      The distributors detect whether there are enough bucket replicas on the
      content nodes and add/remove as needed.
      Write operations wait for replies from every replica
      and fail if less than redundancy are persisted within timeout.
    </p>
  </td>
</tr><tr id="cluster-controller">
  <th>Cluster controller</th>
  <td>
    The <a href="content/content-nodes.html#cluster-controller">cluster controller</a>
    manages the state of the distributor and content nodes.
    This <em>cluster state</em> is used by the document processing chains
    to know which distributor to send documents to,
    as well as by the distributor to know which content nodes should have which bucket.
  </td>
</tr><tr id="content-node">
  <th>Proton</th>
  <td>
    <a href="proton.html">Proton</a> node has a <em>bucket management system</em>,
    which sends requests to a set of <em>document databases</em>,
    which each consists of three <em>sub-databases</em>.
    In short, this node activates and deactivates buckets for queries.
  </td>
</tr>
</tbody>
</table>



<h2 id="troubleshooting">Troubleshooting</h2>
<table class="table">
  <tr>
    <th>Routing</th>
    <td>
      <p>
        Vespa lets application set up custom document processing / indexing,
        with different feed endpoints.
        Refer to <a href="indexing.html">indexing</a> for how to configure this in <em></em>services.xml</em>.
      </p>
      <p>
        <a href="https://github.com/vespa-engine/vespa/issues/13193">#13193</a>
        has a summary of problems and solutions.
      </p>
    </td>
  </tr>
  <tr>
    <th>Tracing</th>
    <td>
      Use <a href="reference/document-v1-api-reference.html#request-parameters">tracelevel</a>
      to dump the routes and hops for a write operation - example:
<pre>
$ curl -H Content-Type:application/json --data-binary @docs.json \
  $ENDPOINT/document/v1/mynamespace/doc/docid/1?tracelevel=4 | jq .

{
    "pathId": "/document/v1/mynamespace/doc/docid/1",
    "id": "id:mynamespace:doc::1",
    "trace": [
        { "message": "[1623413878.905] Sending message (version 7.418.23) from client to ..." },
        { "message": "[1623413878.906] Message (type 100004) received at 'default/container.0' ..." },
        { "message": "[1623413878.907] Sending message (version 7.418.23) from 'default/container.0' ..." },
        { "message": "[1623413878.907] Message (type 100004) received at 'default/container.0' ..." },
        { "message": "[1623413878.909] Selecting route" },
        { "message": "[1623413878.909] No cluster state cached. Sending to random distributor." }
</pre>
    </td>
  </tr>
</table>



<h2 id="further-reading">Further reading</h2>
<ul>
  <li><a href="content/visiting.html">Visiting</a></li>
  <li><a href="document-v1-api-guide.html">/document/v1/ API guide</a></li>
  <li><a href="reference/document-v1-api-reference.html">/document/v1/ API reference</a></li>
</ul>
